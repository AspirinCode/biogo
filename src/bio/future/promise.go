// Implementation of a promise multiple goroutine synchronisation and communication system
// based on the approach used in Alice. Promises will safely allow multiple promisers to
// interact with multiple promisees.
//
// New or non-error Broken Promises can be Fulfilled or Failed, Fulfilled or Failed Promises
// can be Broken and any state of Promise can be Recovered.
//
// Copyright Â©2011 Dan Kortschak <dan.kortschak@adelaide.edu.au>
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
package future

import (
	"bio"
	"sync"
	"os"
)

type scroll struct {
	value interface{}
	error os.Error
}

// Promises can be mutable or not, recoverable or not and may relay internal error states
// to other listeners.
// Mutable promises may have their value state changed with subsequence Fulfill calls.
// Recoverable promises may be recovered after a Fail call.
// Promises created with relay set to true will relay an error generated by attempting to
// fulfill an immutable fulfilled promise.
type Promise struct {
	message chan scroll
	sync.Mutex
	mutable     bool
	recoverable bool
	relay       bool
}

// Create a new promise
func NewPromise(mutable, recoverable, relay bool) *Promise {
	return &Promise{
		message:     make(chan scroll, 1),
		mutable:     mutable,
		recoverable: recoverable,
		relay:       relay,
	}

}

func (self *Promise) messageState() (message scroll, set bool) {
	select {
	case message = <-self.message:
		set = true
	default:
	}

	return
}

// Fulfill a promise, allowing listeners to unblock.
func (self *Promise) Fulfill(value interface{}) os.Error {
	self.Lock()
	defer self.Unlock()

	return self.fulfill(value)
}

func (self *Promise) fulfill(value interface{}) (e os.Error) {
	m, set := self.messageState()

	if m.error != nil {
		e = bio.NewError("Tried to fulfill a failed promise", 0, m.error)
	} else {
		if !set || self.mutable {
			m.value = value
			e = nil
		} else {
			e = bio.NewError("Tried to fulfill an already set immutable promise", 0, nil)
		}
	}

	if e != nil && self.relay {
		if m.error != nil {
			e = bio.NewError("Promise already failed - cannot relay", 0, m.error)
		} else {
			m.error = e
		}
	}

	self.message <- m

	return
}

// Fail a promise allowing listeners to unblock, but sending an error state.
func (self *Promise) Fail(value interface{}, error os.Error) bool {
	self.Lock()
	defer self.Unlock()

	return self.fail(value, error)
}

func (self *Promise) fail(value interface{}, error os.Error) (f bool) {
	m, _ := self.messageState()

	if m.error == nil && m.value == nil {
		if value != nil {
			m.value = value
		}
		m.error = error
		f = true
	} else {
		f = false
	}

	self.message <- m

	return
}

// Recover a failed promise, setting the error state to nil. Promise must be recoverable.
func (self *Promise) Recover(value interface{}) (r bool) {
	self.Lock()
	defer self.Unlock()

	m, _ := self.messageState()

	if self.recoverable {
		m.error = nil
		if value != nil {
			self.fulfill(value)
		}
		r = true
	} else {
		r = false
	}

	return
}

// Break an already fulfilled or failed promise, blocking all listeners.
func (self *Promise) Break() {
	self.Lock()
	defer self.Unlock()

	self.messageState()
}

// Wait for a promise to be fulfilled, failed or recovered.
func (self *Promise) Future() (interface{}, os.Error) {
	m := <-self.message
	self.message <- m
	return m.value, m.error
}
