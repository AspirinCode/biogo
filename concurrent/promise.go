package concurrent

// Copyright Â©2011 Dan Kortschak <dan.kortschak@adelaide.edu.au>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import (
	"github.com/kortschak/biogo/bio"
	"sync"
)

// Implementation of a promise multiple goroutine synchronisation and communication system
// based on the approach used in Alice. Promises will safely allow multiple promisers to
// interact with multiple promisees.
//
// New or non-error Broken Promises can be Fulfilled or Failed. Fulfilled or Failed Promises
// can be Broken and any state of Promise can be Recovered if specified at creation.
//
// Promises can be mutable or not, recoverable or not and may relay internal error states
// to other listeners.
// Mutable promises may have their value state changed with subsequence Fulfill calls.
// Recoverable promises may be recovered after a Fail call.
// Promises created with relay set to true will relay an error generated by attempting to
// fulfill an immutable fulfilled promise.
type Promise struct {
	message     chan Result
	m           sync.Mutex
	mutable     bool
	recoverable bool
	relay       bool
}

// Create a new promise
func NewPromise(mutable, recoverable, relay bool) *Promise {
	return &Promise{
		message:     make(chan Result, 1),
		mutable:     mutable,
		recoverable: recoverable,
		relay:       relay,
	}

}

func (self *Promise) messageState() (message Result, set bool) {
	select {
	case message = <-self.message:
		set = true
	default:
	}

	return
}

// Fulfill a promise, allowing listeners to unblock.
func (self *Promise) Fulfill(value interface{}) error {
	self.m.Lock()
	defer self.m.Unlock()

	return self.fulfill(value)
}

func (self *Promise) fulfill(value interface{}) (err error) {
	r, set := self.messageState()

	if r.Err != nil {
		err = bio.NewError("Tried to fulfill a failed promise", 0, r.Err)
	} else {
		if !set || self.mutable {
			r.Value = value
			err = nil
		} else {
			err = bio.NewError("Tried to fulfill an already set immutable promise", 0)
		}
	}

	if err != nil && self.relay {
		if r.Err != nil {
			err = bio.NewError("Promise already failed - cannot relay", 0, r.Err)
		} else {
			r.Err = err
		}
	}

	self.message <- r

	return
}

// Fail a promise allowing listeners to unblock, but sending an error state.
func (self *Promise) Fail(value interface{}, err error) (ok bool) {
	self.m.Lock()
	defer self.m.Unlock()

	return self.fail(value, err)
}

func (self *Promise) fail(value interface{}, err error) (f bool) {
	r, _ := self.messageState()

	if r.Err == nil && r.Value == nil {
		if value != nil {
			r.Value = value
		}
		r.Err = err
		f = true
	} else {
		f = false
	}

	self.message <- r

	return
}

// Recover a failed promise, setting the error state to nil. Promise must be recoverable.
func (self *Promise) Recover(value interface{}) (ok bool) {
	self.m.Lock()
	defer self.m.Unlock()

	r, _ := self.messageState()

	if self.recoverable {
		r.Err = nil
		if value != nil {
			self.fulfill(value)
		}
		ok = true
	} else {
		ok = false
	}

	return
}

// Break an already fulfilled or failed promise, blocking all listeners.
func (self *Promise) Break() {
	self.m.Lock()
	defer self.m.Unlock()

	self.messageState()
}

// Wait for a promise to be fulfilled, failed or recovered.
func (self *Promise) Wait() (<-chan Result) {
	r := <-self.message
	self.message <- r
	f := make(chan Result, 1)
	f <- r
	close(f)
	return f
}
